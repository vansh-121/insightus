# -*- coding: utf-8 -*-
"""KnowledgeRepresentation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NWhyaXayMZsUzDm1unlTVbFaSY4OGDB-
"""

""" Class KnowledgeRepresentation"""




from pyspark.sql import SparkSession
class KnowledgeRepresentation:

    def __init__(self):
        pass

    def show_frequencies(self, dataframe, target):
        import matplotlib.pyplot as plt
        import matplotlib
        matplotlib.use('Agg')
        import io
        import base64

        # Separate numeric and categorical columns
        numeric_columns = dataframe.select_dtypes(
            include=['number']).columns.tolist()
        categorical_columns = dataframe.select_dtypes(
            include=['object', 'category']).columns.tolist()

        # Remove target column from appropriate list
        if target in numeric_columns:
            numeric_columns.remove(target)
        elif target in categorical_columns:
            categorical_columns.remove(target)

        # Remove boolean columns from categorical columns
        boolean_columns = [
            col for col in categorical_columns if dataframe[col].nunique() == 2]
        categorical_columns = [
            col for col in categorical_columns if col not in boolean_columns]
        boolean_columns += [col for col in numeric_columns if dataframe[col].nunique() == 2]
        numeric_columns = [
            col for col in numeric_columns if col not in boolean_columns]

        # Define a function to plot histograms for numeric columns
        def plot_histogram(ax, data, col):
            data = data.dropna()
            ax.hist(data, bins=30, edgecolor='black')
            mean = data.mean()
            std_dev = data.std()
            ax.axvline(mean, color='r', linestyle='--',
                       linewidth=2, label='Mean')
            ax.axvline(mean + 3 * std_dev, color='g', linestyle='--',
                       linewidth=2, label='Mean + 3 Std Dev')
            ax.axvline(mean - 3 * std_dev, color='g', linestyle='--',
                       linewidth=2, label='Mean - 3 Std Dev')
            ax.legend()
            ax.set_title(f"Histogram of {col}")
            ax.set_xlabel(col)
            ax.set_ylabel("Frequency")

        # Define a function to plot bar plots for categorical columns
        def plot_bar(ax, data, col):
            data[col].value_counts().plot(
                kind='bar', ax=ax, color='aquamarine', edgecolor='black')
            ax.set_title(f"Bar Plot of {col}")
            ax.set_xlabel(col)
            ax.set_ylabel("Frequency")

        # Define a function to plot pie charts for boolean columns
        def plot_pie(ax, data, col):
            data[col].value_counts().plot.pie(
                autopct='%1.1f%%', startangle=90, ax=ax)
            ax.set_title(f"Pie Chart of {col}")
            ax.set_ylabel('')

        # Calculate total number of plots and rows required
        num_plots = len(numeric_columns) + \
            len(categorical_columns) + len(boolean_columns) + 1
        num_rows = (num_plots + 1) // 2

        # Create figure and subplots
        fig, axs = plt.subplots(
            num_rows, 2, figsize=(20, 8 * num_rows), dpi=100)

        # Flattened index for placing the target plot in the correct position
        plot_index = 0

        # Plot numeric columns
        for col in numeric_columns:
            row, col_idx = divmod(plot_index, 2)
            plot_histogram(axs[row, col_idx], dataframe[col], col)
            axs[row, col_idx].annotate('Numeric Column', xy=(0.5, 1.175), xycoords='axes fraction',
                                       ha='center', va='center', fontsize=24, fontweight='bold')
            plot_index += 1

        # Plot categorical columns
        for col in categorical_columns:
            row, col_idx = divmod(plot_index, 2)
            plot_bar(axs[row, col_idx], dataframe, col)
            axs[row, col_idx].annotate('Categorical Column', xy=(0.5, 1.175), xycoords='axes fraction',
                                       ha='center', va='center', fontsize=24, fontweight='bold')
            plot_index += 1

        # Plot boolean columns
        for col in boolean_columns:
            row, col_idx = divmod(plot_index, 2)
            plot_pie(axs[row, col_idx], dataframe, col)
            axs[row, col_idx].annotate('Boolean Column', xy=(0.5, 1.175), xycoords='axes fraction',
                                       ha='center', va='center', fontsize=24, fontweight='bold')
            plot_index += 1

        # Plot target column as pie chart in the last available subplot
        row, col_idx = divmod(plot_index, 2)
        plot_pie(axs[row, col_idx], dataframe, target)
        axs[row, col_idx].annotate('Target Column', xy=(
            0.5, 1.175), xycoords='axes fraction', ha='center', va='center', fontsize=24, fontweight='bold')
        plot_index += 1

        # Turn off visibility for remaining subplots
        while plot_index < num_rows * 2:
            row, col_idx = divmod(plot_index, 2)
            axs[row, col_idx].axis('off')
            plot_index += 1

        # Adjust layout and display
        plt.tight_layout()
        plt.subplots_adjust(hspace=0.8, wspace=0.2)

        # Save the plot to a bytes buffer instead of showing it
        buf = io.BytesIO()
        plt.savefig(buf, format='png')
        buf.seek(0)
        plot_data = base64.b64encode(buf.read()).decode('utf-8')
        plt.close(fig)

        return plot_data

    # Method to Generate Graphs of Distribution of Columns by Target

    def show_distribution(self, dataframe, target):
        import matplotlib.pyplot as plt
        import matplotlib
        matplotlib.use('Agg')
        import seaborn as sns
        import numpy as np
        import io
        import base64

        # Separate numeric and categorical columns
        numeric_columns = dataframe.select_dtypes(
            include=np.number).columns.tolist()
        categorical_columns = dataframe.select_dtypes(
            include=['object', 'category']).columns.tolist()

        if target in numeric_columns:
            numeric_columns.remove(target)
            target_is_numeric = True
        elif target in categorical_columns:
            categorical_columns.remove(target)
            target_is_numeric = False

        boolean_columns = [
            col for col in categorical_columns if dataframe[col].nunique() == 2]
        categorical_columns = [
            col for col in categorical_columns if col not in boolean_columns]
        boolean_columns += [col for col in numeric_columns if dataframe[col].nunique() == 2]
        numeric_columns = [
            col for col in numeric_columns if col not in boolean_columns]

        num_plots = len(numeric_columns) + \
            len(categorical_columns) + len(boolean_columns)
        # Calculate number of rows needed (two plots per row)
        num_rows = (num_plots + 1) // 2

        fig, axs = plt.subplots(num_rows, 2, figsize=(18, 6 * num_rows))

        idx = 0

        # Function to add a title above each category of graphs
        def add_category_title(ax, title):
            ax.text(0.5, 1.1, title, fontsize=24, fontweight='bold',
                    ha='center', transform=ax.transAxes)

        for col in numeric_columns:
            row_idx = idx // 2
            col_idx = idx % 2

            if target_is_numeric:
                sns.scatterplot(x=target, y=col, data=dataframe,
                                ax=axs[row_idx, col_idx])
                axs[row_idx, col_idx].set_title(
                    f'Scatter Plot of {col} by {target}')
            else:
                sns.stripplot(x=target, y=col, data=dataframe,
                              ax=axs[row_idx, col_idx])
                axs[row_idx, col_idx].set_title(
                    f'Strip Plot of {col} by {target}')
            axs[row_idx, col_idx].set_xlabel(target)
            axs[row_idx, col_idx].set_ylabel(col)
            plt.setp(
                axs[row_idx, col_idx].xaxis.get_majorticklabels(), rotation=90)
            add_category_title(axs[row_idx, col_idx], 'Numeric Column')

            idx += 1

        for col in categorical_columns:
            row_idx = idx // 2
            col_idx = idx % 2

            if target_is_numeric:
                sns.stripplot(x=col, y=target, data=dataframe,
                              ax=axs[row_idx, col_idx])
                axs[row_idx, col_idx].set_title(
                    f'Strip Plot of {target} by {col}')
            else:
                sns.countplot(x=col, hue=target, data=dataframe,
                              ax=axs[row_idx, col_idx])
                axs[row_idx, col_idx].set_title(
                    f'Count Plot of {col} by {target}')
                plt.setp(
                    axs[row_idx, col_idx].xaxis.get_majorticklabels(), rotation=90)
            axs[row_idx, col_idx].set_xlabel(col)
            add_category_title(axs[row_idx, col_idx], 'Categorical Column')

            idx += 1

        for col in boolean_columns:
            row_idx = idx // 2
            col_idx = idx % 2

            if target_is_numeric:
                sns.stripplot(x=col, y=target, data=dataframe,
                              ax=axs[row_idx, col_idx])
                axs[row_idx, col_idx].set_title(
                    f'Strip Plot of {target} by {col}')
            else:
                counts = dataframe.groupby(
                    [target, col]).size().unstack().fillna(0)
                counts.plot(kind='bar', stacked=True, ax=axs[row_idx, col_idx])
                axs[row_idx, col_idx].set_title(
                    f'Stacked Bar Plot of {col} by {target}')
                axs[row_idx, col_idx].set_xlabel(target)
                axs[row_idx, col_idx].set_ylabel('Count')
                plt.setp(
                    axs[row_idx, col_idx].xaxis.get_majorticklabels(), rotation=90)
            add_category_title(axs[row_idx, col_idx], 'Boolean Column')

            idx += 1

        # Hide unused subplots if there are an odd number of plots
        if num_plots % 2 != 0:
            fig.delaxes(axs.flatten()[-1])

        fig.tight_layout()

        # Save the plot to a bytes buffer instead of showing it
        buf = io.BytesIO()
        plt.savefig(buf, format='png')
        buf.seek(0)
        plot_data = base64.b64encode(buf.read()).decode('utf-8')
        plt.close(fig)

        return plot_data

    # Method to Show Descriptive Statistics
    def show_describe_stats(self, dataframe, target):

        # To Generate Statistics from the dataset in Natural Language
        import google.generativeai as genai

        # Giving API Key ro Configure model
        genai.configure(api_key="AIzaSyAfe09bOemDufX_OyYz8qkL1tAPcpdn9WU")

        model = genai.GenerativeModel(
            model_name='gemini-1.5-pro',
            tools='code_execution'
        )

        desc = dataframe.describe()

        prompt = f"""{desc}\
            Please represent the statistics of a DataFrame\
            in the following tableless descriptive manner: \
            First point with bullet(dot darkend) is the total\
            number of entries in the dataframe and then\
            give bullet(dot darkend) before every column name and\
            then name of column name (capitalized)\
            and give two newlines after column name\
            and then for every separate point in the column,\
            must give a bullet(dot darkend) before\
            the name of the point in a good format\
            then complete detailed explanation of\
            the point. Everything must be in plane text\
            without bold headings and markdowns\
            and do not use redundant sentences."""

        response = model.generate_content(prompt)

        unique_values = dataframe[target].value_counts()

        prompt = f'''{unique_values}\
            is a dataframe representing the count of all unique\
            values of the target column.Tell about the skewness\
            of the dataset in three to four points with bullets(dot darkend)\
            and must not use redundant sentences such as python code\
            and must not use bold headings and markdowns.\
            Must give a bullet(dot darkend) before\
            every point and also add a new line after\
            every point.'''

        response2 = model.generate_content(prompt)

        return response.text, response2.text


if __name__ == "__main__":

    from Data_Preprocessing import DataPreprocessing
    from pyspark.sql import SparkSession
    dp = DataPreprocessing()
    spark = SparkSession.builder.appName(
        "Knowledge Representation").getOrCreate()

    dataframe = dp.readCsv(session=spark)

    if 'id' in dataframe.columns:
        dataframe = dataframe.drop('id')

    # dataframe.show()

    numeric_cols = []
    categorical_cols = []

    for col in dataframe.columns:
        if dataframe.select(col).dtypes[0][1] == 'string' or dataframe.select(col).dtypes[0][1] == 'boolean':
            categorical_cols.append(col)
        else:
            numeric_cols.append(col)

    dataframe = dp.fillMissingValues(dataframe, numeric_cols, categorical_cols)

    dataframe = dp.removeOutliers(dataframe, numeric_cols)

    dataframe = dp.LabelEncoding(dataframe, categorical_cols)

    dataframe = dp.NormalizeNumericColumns(
        dataframe, numeric_cols + categorical_cols)

    dataframe = dataframe.drop('features')

    # dataframe.show()

    df_pandas = dataframe.toPandas()

    kr = KnowledgeRepresentation()
    kr.show_frequencies(df_pandas, 'income')

    # kr = KnowledgeRepresentation()
    kr.show_distribution(df_pandas, 'income')

    # kr = KnowledgeRepresentation()
    kr.show_describe_stats(df_pandas, 'income')

    spark.stop()
